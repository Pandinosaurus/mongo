/**
 *    Copyright (C) 2026-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 */

#include "mongo/shell/debugger/adapter.h"

#include "mongo/bson/bsonobjbuilder.h"
#include "mongo/bson/json.h"
#include "mongo/bson/oid.h"
#include "mongo/shell/debugger/debugger.h"
#include "mongo/stdx/condition_variable.h"
#include "mongo/stdx/mutex.h"

#ifdef _WIN32
#include <winsock2.h>
#include <ws2tcpip.h>
#else
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/socket.h>
#endif


namespace mongo {
namespace mozjs {

constexpr int INVALID_SOCKET_VALUE = -1;

// Network state
int _clientSocket = INVALID_SOCKET_VALUE;
AtomicWord<bool> _running{false};
std::unique_ptr<std::thread> _messageThread;

// Configuration state
stdx::mutex _configMutex;
stdx::condition_variable _configCV;


/**
 * Request
 */

Request Request::fromJSON(std::string line) {
    BSONObj obj = fromjson(line);

    Request msg;
    msg.seq = obj.getIntField("seq");
    msg.command = std::string(toStdStringViewForInterop(obj.getStringField("command")));
    msg.arguments = obj.getObjectField("arguments");

    return msg;
}

/**
 * SetBreakpointsRequest
 */

SetBreakpointsRequest::SetBreakpointsRequest(Request request) {
    seq = request.seq;

    // Get source from arguments
    source = std::string(toStdStringViewForInterop(request.arguments.getStringField("source")));

    // Get lines array from arguments and extract line numbers
    std::vector<BSONElement> linesArr = request.arguments.getField("lines").Array();
    for (const auto& lineElem : linesArr) {
        BSONObj lineObj = lineElem.Obj();
        int lineNum = lineObj.getIntField("line");
        lines.push_back(lineNum);
    }
}

void SetBreakpointsRequest::respond() {
    // STUB response for now, simply match the "seq" for DAP to sync
    DebugAdapter::sendMessage("{\"type\":\"response\",\"seq\":" + std::to_string(seq) +
                              ",\"body\":{\"breakpoints\":[{\"id\":\"1\","
                              "\"verified\":true,\"line\":\"12\","
                              "\"column\":\"0\"}]}}");
}

/**
 * ContinueRequest
 */

ContinueRequest::ContinueRequest(Request request) {
    seq = request.seq;
}

void ContinueRequest::respond() {
    DebugAdapter::sendMessage("{\"type\":\"response\",\"seq\":" + std::to_string(seq) +
                              ",\"command\":\"continue\",\"success\":true}");
}

/**
 * StackTraceRequest
 */

StackTraceRequest::StackTraceRequest(Request request) {
    seq = request.seq;
}

void StackTraceRequest::respond() {
    DebugAdapter::sendMessage(
        "{\"type\":\"response\",\"seq\":" + std::to_string(seq) +
        ",\"body\":{\"stackFrames\":[{\"id\":1,\"name\":\"" + DebuggerGlobal::getPausedScript() +
        "\",\"source\":{\"path\":\"" + DebuggerGlobal::getPausedScript() +
        "\"},\"line\":" + std::to_string(DebuggerGlobal::getPausedLine()) + ",\"column\":0}]}}");
}

/**
 * StoppedEvent
 */

void StoppedEvent::send() {
    // Send a "stopped" event to the DAP adapter
    DebugAdapter::sendMessage(
        "{\"type\":\"event\",\"event\":\"stopped\","
        "\"body\":{\"reason\":\"breakpoint\"}}");
}

/**
 * DebugAdapter
 */

void DebugAdapter::handleRequest(Request request) {
    if (request.command == "setBreakpoints") {
        SetBreakpointsRequest req(request);
        DebugAdapter::handleRequest(req);
    } else if (request.command == "continue") {
        ContinueRequest req(request);
        DebugAdapter::handleRequest(req);
    } else if (request.command == "stackTrace") {
        StackTraceRequest req(request);
        DebugAdapter::handleRequest(req);
    }
    // TODO: Add other commands: scopes, variables, next, stepIn, stepOut
}

void DebugAdapter::handleRequest(SetBreakpointsRequest request) {
    DebuggerGlobal::setBreakpoints(request);
    request.respond();
}

void DebugAdapter::handleRequest(ContinueRequest request) {
    DebuggerGlobal::unpause();
    request.respond();
}

void DebugAdapter::handleRequest(StackTraceRequest request) {
    request.respond();
}

void DebugAdapter::waitForHandshake() {
    // The DAP should already be running, which is probing the port for when to attach to a new
    // shell. The shell can come up and start running tests before the DAP gets to relay any pending
    // breakpoints. We need to wait for the DAP to sync up, and then continue.

    std::unique_lock<std::mutex> lock(_configMutex);
    // TODO(SERVER-XXX): this is just a straight up 1-second pause, and can/should be more elegant
    _configCV.wait_for(lock, std::chrono::seconds(1), [] { return false; });
}

void DebugAdapter::sendPause() {
    StoppedEvent e;
    e.send();
}

void DebugAdapter::sendMessage(std::string json) {
    if (_clientSocket < 0)
        return;
    send(_clientSocket, json.c_str(), json.length(), 0);
}

void DebugAdapter::handleMessagesThread() {
    char buffer[4096];
    std::string msgBuffer;

    while (_running.load() && _clientSocket >= 0) {
        auto n = recv(_clientSocket, buffer, sizeof(buffer), 0);
        if (n <= 0) {
            break;  // Connection closed or error
        }

        msgBuffer.append(buffer, n);

        // Process complete messages (newline-delimited JSON)
        size_t pos;
        while ((pos = msgBuffer.find('\n')) != std::string::npos) {
            std::string line = msgBuffer.substr(0, pos);
            msgBuffer.erase(0, pos + 1);

            if (!line.empty()) {
                // Parse and handle message
                Request req;
                try {
                    req = Request::fromJSON(line);
                } catch (const std::exception& e) {
                    std::cout << "[ERROR] Failed to parse JSON: " << e.what() << "\nLine: " << line
                              << std::endl;
                }
                handleRequest(req);
            }
        }
    }

    DebugAdapter::disconnect();
}


Status DebugAdapter::connect() {
#ifdef _WIN32
    // Initialize Winsock on Windows
    WSADATA wsaData;
    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
        return Status(ErrorCodes::JSInterpreterFailure, "Failed to initialize Winsock");
    }
#endif

    // Create CLIENT socket (connecting to debug adapter)
    _clientSocket = socket(AF_INET, SOCK_STREAM, 0);
    if (_clientSocket < 0) {
#ifdef _WIN32
        WSACleanup();
#endif
        return Status(ErrorCodes::JSInterpreterFailure, "Failed to create client socket");
    }

    // Set up address to connect to debug adapter client
    int port = 9229;
    sockaddr_in addr;
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    inet_pton(AF_INET, "127.0.0.1", &addr.sin_addr);

    if (::connect(_clientSocket, (sockaddr*)&addr, sizeof(addr)) == 0) {
        std::cout << "Shell connected to debug adapter client on port " << port << std::endl;
        _running.store(true);
        _messageThread = std::make_unique<std::thread>(handleMessagesThread);
    }

    return Status::OK();
}

void DebugAdapter::disconnect() {
    if (_clientSocket >= 0) {
#ifdef _WIN32
        closesocket(_clientSocket);
        WSACleanup();
#else
        close(_clientSocket);
#endif
    }
    _clientSocket = INVALID_SOCKET_VALUE;
}

}  // namespace mozjs
}  // namespace mongo
